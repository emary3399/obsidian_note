​ ​**一、事务的基本概念**​

​**1. 定义**​  
事务（Transaction）是一组**不可分割**的数据库操作指令，要么**全部执行成功**，要么**全部不执行**​（回滚）。

​**举例**​：银行转账（A转200元给B）：

- A账户减200元
- B账户加200元  
    ​**要么都成功，要么都失败**，不能只执行一半。

---

#### ​**二、事务的四大特性（ACID）​**​

|​**特性**​|​**解释**​|​**例子**​|
|---|---|---|
|​**原子性**​|事务是一个整体，不可分割（要么全做，要么全不做）|转账时A扣款和B收款必须同时完成|
|​**一致性**​|事务执行后，数据库从一个一致状态变为另一个一致状态|转账前后总金额不变（A+B=1500元）|
|​**隔离性**​|并发事务之间互不干扰（一个事务的执行不应影响其他事务）|事务A转账时，事务B不能同时修改A余额|
|​**持久性**​|事务提交后，结果永久保存（即使系统崩溃也不丢失）|转账成功后，余额变化永久生效|

---

#### ​**三、事务控制语句**​

- ​`BEGIN TRANSACTION`​：开始事务
- ​`COMMIT`：提交事务（成功执行）
- ​`ROLLBACK`​：回滚事务（失败时恢复原始状态）

​**示例**​：

```sql
BEGIN TRANSACTION;  -- 开始事务
UPDATE Account SET balance = balance - 200 WHERE id = 'A';  -- A扣款
UPDATE Account SET balance = balance + 200 WHERE id = 'B';  -- B收款
COMMIT;  -- 提交事务（若失败则自动ROLLBACK）
```

---

#### ​**四、并发操作的问题**​

​**1. 丢失更新（Lost Update）​**​

- ​**问题**​：两个事务同时修改同一数据，后提交的覆盖前提交的结果。
- ​**例子**​：A和B同时读取余额为100元，A减10元（90），B减20元（80），最终余额错误（应为70元）。

​**2. 不可重复读（Non-Repeatable Read）​**​

- ​**问题**​：同一事务内两次读取同一数据，结果不同（因其他事务修改了数据）。
- ​**例子**​：事务A第一次读余额为100元，事务B修改为80元后，事务A第二次读变为80元。

​**3. 脏读（Dirty Read）​**​

- ​**问题**​：读取到其他事务未提交的临时数据（可能被回滚）。
- ​**例子**​：事务A修改余额为200元（未提交），事务B读到200元后，事务A回滚，实际余额仍为100元。

#### ​**五、事务的隔离级别**

| 隔离级别                   | 脏读（赃读） | 不可重复读 | 幻读  |
| ---------------------- | ------ | ----- | --- |
| Read uncommitted       | √      | √     | √   |
| Read committed         | √      | √     | √   |
| Repeatingable Read(默认) | ×      | ×     | √   |
| Serializable           | ×      | ×     | ×   |

- ​**封锁协议是底层技术**，隔离级别是上层标准。

|​**隔离级别**​|​**对应的封锁协议级别**​|​**解决的问题**​|​**实现方式（锁机制）​**​|
|---|---|---|---|
|​**Read Uncommitted**​|无直接对应（类似一级封锁协议，但更宽松）|不解决任何问题（允许脏读、不可重复读、幻读）|读数据时不加锁，写数据时加X锁（短暂持有）|
|​**Read Committed**​|二级封锁协议|防止**脏读**​（但允许不可重复读、幻读）|读数据时加S锁（读完后立即释放），写数据时加X锁（持有至事务结束）|
|​**Repeatable Read**​|三级封锁协议|防止**脏读**和**不可重复读**​（但允许幻读）|读数据时加S锁（持有至事务结束），写数据时加X锁（持有至事务结束）|
|​**Serializable**​|严格三级封锁协议 + 范围锁|防止**脏读、不可重复读、幻读**​（最高隔离级别）|对查询范围加锁（如间隙锁、Next-Key Lock），确保事务完全串行化执行|

