### ​**问题1：员工表属于哪种关系范式？​**​

​**正确答案：A. 非1NF关系**​

### ​**解析：多值属性与范式的关系**​

1. ​**第一范式（1NF）的核心要求**​：
    
    - 关系的每个属性必须是**原子（不可再分）​**，且不能有**多值属性**。
    - ​**​“联系电话”是多值属性**​（如一个员工有多个电话号），违反了1NF的原子性。
2. ​**其他范式的排除**​：
    
    - 1NF是基础，若不满足1NF，则更高范式（2NF/3NF）自动不满足。
    - 因此，选项B/C/D均错误。

---

### ​### ​**问题2：在SQL:1999标准中如何实现多值属性？​**​

​**正确答案：A. 集合类型**​

### ​**解析：SQL:1999对多值属性的支持**​

1. ​**集合类型（Collection Types）​**​
    
    - ​**ARRAY**​：固定长度的多值集合（如 `VARCHAR(20) ARRAY[5]` 存储最多5个电话号）。
    - ​**MULTISET**​：可变长度的多值集合（允许重复元素）。
    - ​**嵌套表（Nested Table）​**​：动态扩展的多值集合（需单独定义表类型）。
2. ​**其他选项排除**​
    
    - ​**B. CLOB类型**​：存储大文本（如长文章），不支持多值。
    - ​**C. BLOB类型**​：存储二进制数据（如图片），不支持多值。
    - ​**D. 结构类型**​：用于定义复杂对象（如`CREATE TYPE`），但不直接解决多值属性。
3. ​**SQL:1999示例**​
    

    ```sql
    -- 使用ARRAY存储多值联系电话
    CREATE TABLE 员工 (
        工号 INT PRIMARY KEY,
        姓名 VARCHAR(50),
        联系电话 VARCHAR(20) ARRAY[3]  -- 允许存储3个电话号
    );
    
    -- 使用嵌套表（需先定义类型）
    CREATE TYPE 电话类型 AS TABLE OF VARCHAR(20);
    CREATE TABLE 员工 (
        工号 INT PRIMARY KEY,
        姓名 VARCHAR(50),
        联系电话 电话类型  -- 多值存储
    ) NESTED TABLE 联系电话 STORE AS 电话表;
    ```
    

### ​**应试技巧**​

- 看到**多值属性**和**SQL:1999**​ → 直接选**集合类型**​（ARRAY/MULTISET/嵌套表）。
- CLOB/BLOB是单值大对象，结构类型用于复杂对象而非多值。

​**答案：A ✅**    ```
    

---

### **1NF（第一范式）详解**​

#### ​1. 定义

​**第一范式（1NF）​**是关系数据库设计的**最基本要求**，核心规则是：

- ​**每个属性（列）的值必须是原子的（不可再分）​**。
- ​**每行数据必须唯一，且不允许重复组或多值属性**。

#### ​**2. 关键要求**​

|要求|符合1NF的示例|违反1NF的示例|
|---|---|---|
|​**原子性**​|电话号码：`"13800138000"`|电话号码：`"13800138000,13900139000"`（多值）|
|​**无重复组**​|订单表分开存储商品ID和数量|订单表中一列存储`"商品1:2,商品2:3"`|
|​**列名唯一**​|列名为`姓名`、`年龄`|同一列存储`姓名`和`年龄`混合数据|

#### ​**3. 为什么重要？​**​

- ​**数据完整性**​：避免歧义（如拆分多值数据时可能出错）。
- ​**查询效率**​：原子数据更易索引和过滤。
- ​**后续范式的基础**​：2NF/3NF均以1NF为前提。

#### ​**4. 常见违反场景**​

- ​**多值属性**​（如员工有多个联系电话）。
- ​**复合字段**​（如地址合并为`"北京市海淀区中关村大街1号"`，需拆分为省/市/详细地址）。
- ​**重复组**​（如订单中同一单元格存储多个商品）。

#### ​**5. 如何满足1NF？​**​

- ​**拆分多值属性**​：
    - 错误：`联系电话: "123-456,789-012"`
    - 正确：新增从表（如`员工_电话`表），关联主键。
- ​**分解复合字段**​：
    - 错误：`地址: "北京市海淀区中关村"`
    - 正确：分列→ `省: "北京市"`, `市: "海淀区"`, `详细地址: "中关村"`。

#### ​**6. 示例对比**​

​**违反1NF的表（员工表）​**​

|工号|姓名|联系电话|
|---|---|---|
|001|张三|13800138000,13912345678|

#### ​**7. 应试技巧**​

- 看到**多值属性**或**复合字段**​ → 直接判断为**非1NF**。
- 1NF的核心是**原子性**，与数据是否冗余或依赖无关（这是2NF/3NF的事）。

​**总结**​：1NF是关系数据库的“底线”，确保数据可被高效、无歧义地存储和查询。

---
### ​**问题1：事务处理时，数据的修改内容先写入哪里？​**​

​**正确答案：C. 日志文件（Log File）​**​

### ​**问题2：系统正常运行时，数据库缓冲区内容写入哪里？​**​

​**正确答案：B. 数据文件（Data File）​**​

---

### ​**详细解析：数据库事务与恢复机制**​

#### ​**1. 事务处理的核心流程**​

为了保证数据安全，数据库采用 ​**WAL（Write-Ahead Logging）​**​ 机制：

1. ​**先写日志**​：任何数据修改（插入/删除/更新）​**先记录到日志文件**​（确保可追溯）。
2. ​**再写数据**​：日志记录成功后，才将数据写入内存缓冲区，最终刷盘到数据文件。

#### ​**2. 各文件的作用**​

|文件类型|用途|对应问题答案|
|---|---|---|
|​**日志文件**​|记录所有数据修改操作（如`UPDATE users SET name='张三' WHERE id=1`）|​**问题1选C**​|
|​**数据文件**​|存储实际数据（如用户表、订单表）|​**问题2选B**​|
|​**索引文件**​|加速查询（如B+树索引），与事务安全无关|❌ 不选|
|​**数据字典**​|存储元数据（如表结构定义），与事务无关|❌ 不选|

#### ​**3. 为什么先写日志？​**​

- ​**故障恢复**​：如果系统崩溃，数据库可以根据日志重放（Redo）或回滚（Undo）操作，保证数据一致性。
- ​**性能优化**​：日志是顺序写入（速度快），而数据文件可能随机写入（慢）。

#### ​**4. 缓冲区写入数据文件的时机**​

- ​**定期刷盘**​：系统按时间间隔（如每秒）将内存缓冲区的脏数据写入数据文件。
- ​**强制刷盘**​：事务提交时，确保日志持久化后，才允许缓冲区异步写入数据文件。

#### ​**5. 故障恢复示例**​

- ​**场景**​：系统在更新用户余额时断电。
    - ​**日志记录**​：`UPDATE accounts SET balance=500 WHERE id=100`（已写入日志文件）。
    - ​**数据文件未更新**​：内存缓冲区丢失，数据文件中余额仍为旧值。
    - ​**恢复过程**​：重启后根据日志重做（Redo）该操作，使数据文件与日志一致。

---

### ​**应试技巧**​

1. ​**关键词匹配**​：
    - 看到“先写入” → ​**日志文件**​（WAL机制的核心）。
    - 看到“缓冲区写入” → ​**数据文件**​（最终持久化位置）。
2. ​**排除法**​：
    - 索引文件和数据字典与事务安全无关，直接排除。

​**答案总结**​：

- ​**问题1：C（日志文件）​**​
- ​**问题2：B（数据文件）​**​

​**一句话记忆**​：  
​**​“日志记操作，数据存结果，先日志后数据，故障也不慌！”​**


---
**1. 数据库重组（Reorganization）​**​

- ​**定义**​：​**不改变数据库的逻辑和物理结构**，仅对存储进行优化，如：
    - 重新安排数据存储位置（减少碎片化）
    - 回收垃圾空间（如删除数据后的空闲块）
    - 减少指针链（优化索引或链接结构）
- ​**目的**​：​**提高性能**​（如查询速度、存储效率），但不改变设计。

#### ​**2. 数据库重构（Restructuring）​**​

- ​**定义**​：​**修改数据库的逻辑或物理结构**，如：
    - 增加/删除表、字段、索引
    - 调整关系模式（如规范化或反规范化）
    - 改变存储引擎或分区策略
- ​**目的**​：​**适应需求变化**​（如业务调整、性能瓶颈）。
- ​**对应选项**​：
    - B 错误（重构会修改逻辑或物理结构）。
    - D 错误（描述的是重组的行为，而非重构）。

### ​**应试技巧**​

- ​**重组**​ → ​**​“优化存储，不改变设计”​**​（选 C）。
- ​**重构**​ → ​**​“修改设计”​**​（排除 B 和 D）。
- A 混淆了两者，直接排除。

​**答案：C**​ ✅

---
**题目解析：关于MapReduce技术的说法**​

#### ​**问题：以下哪一项关于MapReduce的说法不正确？​**​

- ​**A**​：MapReduce的计算过程分解为两个主要阶段：Map阶段和Reduce阶段。
- ​**B**​：用户无需编写Map函数和Reduce函数。
- ​**C**​：MapReduce中存在数据chunk的冗余复制。
- ​**D**​：在同等硬件条件下，MapReduce的性能一般低于并行数据库。

---

### ​**逐项分析**​

#### ​**选项A：MapReduce的两阶段计算（Map和Reduce）​**​

- ​**正确**。
    - MapReduce的核心思想确实分为 ​**Map（映射）​**​ 和 ​**Reduce（归约）​**​ 两个阶段。
    - ​**Map阶段**​：对输入数据进行分布式处理，生成键值对（`<key, value>`）。
    - ​**Reduce阶段**​：对Map输出的键值对进行汇总和计算。

#### ​**选项B：用户无需编写Map和Reduce函数**​

- ​**错误**​（本题答案）。
    - ​**MapReduce要求用户必须自定义Map和Reduce函数**，否则无法执行计算。
    - 例如，在Hadoop中，用户需继承`Mapper`和`Reducer`类并实现逻辑。
    - 如果用户不提供这些函数，框架不知道如何处理数据。

#### ​**选项C：数据chunk的冗余复制**​

- ​**正确**。
    - MapReduce（如Hadoop HDFS）默认会对数据分块（chunk）进行**冗余存储**​（通常3副本），以提高容错性。

#### ​**选项D：MapReduce性能低于并行数据库**​

- ​**正确**。
    - MapReduce是为**批处理**设计的，强调高容错和可扩展性，但**单次查询延迟较高**。
    - 并行数据库（如Greenplum、Vertica）针对OLAP优化，在相同硬件下通常性能更高（尤其对复杂查询）。

---

### ​**结论**​

​**不正确的说法是 B**，因为用户必须编写Map和Reduce函数，否则框架无法工作。

---

### ​**应试技巧**​

1. ​**排除法**​：
    - A、C、D的描述均符合MapReduce的特性（两阶段、数据冗余、性能较低）。
    - B明显与事实矛盾（用户必须写函数）。
2. ​**关键记忆点**​：
    - ​**MapReduce的核心是用户自定义Map/Reduce逻辑**，而非全自动。

​**答案：B ✅**

---

### ​**三级结构/两级映像体系结构**​

在数据库的三级模式结构中，​**聚簇索引**和**视图**分别影响不同的层级：

1. ​**聚簇索引（Clustered Index）​**​
    
    - ​**作用**​：改变数据的物理存储顺序（如按某列值排序存储）。
    - ​**影响的层级**​：​**内模式（Internal Schema）​**​
        - 内模式定义数据的物理存储结构和存取方式（如索引、文件组织）。
    - ​**答案**​：​**D. 内模式**​
2. ​**视图（View）​**​
    
    - ​**作用**​：提供一种虚拟表，基于查询逻辑构建，不存储实际数据。
    - ​**影响的层级**​：​**外模式（External Schema）​**​ 和 ​**模式（Conceptual Schema）​**​
        - 外模式是用户看到的数据视图（通过视图实现）。
        - 模式是全体数据的逻辑结构（视图基于模式中的表定义）。
    - ​**题目中第二个空**​：​**模式**​

---

### ​**三级模式结构总结**​

|层级|定义|对应操作|
|---|---|---|
|​**外模式**​|用户视角（如视图）|`CREATE VIEW`|
|​**模式**​|全局逻辑结构（表、关系）|`CREATE TABLE`|
|​**内模式**​|物理存储（文件、索引）|`CREATE INDEX`（聚簇）|

