# 数据库函数依赖集属性分类及候选键求解算法

## 第一步：属性分类
对于给定的关系（A₁, A₂, ..., Aₙ）和函数依赖集F，将属性分为4类：
- ​**L类**​：仅出现在F的函数依赖**左部**的属性
- ​**R类**​：仅出现在F的函数依赖**右部**的属性
- ​**N类**​：在F的函数依赖**左右两边均未出现**的属性
- ​**LR类**​：在F的函数依赖**左右两边均出现**的属性

## 第二步：候选键初筛
1. 令 `X = L ∪ N`
2. 计算 `X⁺`（X的闭包）
3. ​**若 `X⁺ = U`**​（全集），则X是唯一候选键，算法终止

## 第三步：LR属性组合验证
### 单属性组合
1. 从LR中选取<font color="#ff0000">1</font>个属性Y
2. 计算 `(XY)⁺`
3. ​**若 `(XY)⁺ = U`**，则XY是候选键
4. 遍历LR中所有单个属性

### 双属性组合（必要时）
1. 从LR中选取<font color="#ff0000">2</font>个属性Y'
2. 计算 `(XY')⁺`
3. ​**若 `(XY')⁺ = U`**，则XY'是候选键
4. 遍历LR中所有双属性组合

> 📌 ​**关键操作**​：当发现XY是候选键时，立即执行 `LR = LR - Y`

## 注意事项
1. 通常最多验证到双属性组合
2. 若需要验证三属性组合，说明前序步骤可能存在遗漏
3. 算法终止条件：LR属性全部验证完毕

## 小技巧
- 优先测试出现在更多函数依赖中的LR属性
- 闭包计算时注意传递依赖关系
- 用`高亮标注`已确认的候选键属性（如图中黄色标记部分）

---
### 例题
### ​**例题1**​：R(ABC)，F = {A→B, B→C}

#### ​**步骤1：属性分类**​

- ​**L类**​（仅出现在左边）：A
- ​**R类**​（仅出现在右边）：C
- ​**N类**​（未出现）：无
- ​**LR类**​（左右均出现）：B

#### ​**步骤2：候选码初筛**​

1. 初始候选码 = L ∪ N = {A}
2. 计算 {A}⁺：
    - A → B（根据F）
    - B → C（根据F）
    - 因此 {A}⁺ = {A, B, C} = U（全集）

#### ​**结论**​：

- ​**唯一候选码**​：`A`（因为 {A}⁺ = U，且无法再简化）

---

### ​**例题2**​：R(ABCDEG)，F = {AB→C, CD→E, E→A, A→G}

#### ​好的！我们来 **完全从头、一步步严谨又通俗地**重新计算这道题的候选码，目标是让你看懂、记住、不再踩坑。

---

## 📌 题目信息

- 属性集：R = {A, B, C, D, E, G}
    
- 函数依赖集：F =
    
    ```
    AB → C  
    CD → E  
    E → A  
    A → G  
    ```
    

---

## 🧭 步骤1：属性分类（帮助我们初步筛选候选码）

|类别|含义|属性|
|---|---|---|
|L类|只出现在依赖左边的属性|**B, D**|
|R类|只出现在依赖右边的属性|**G**|
|LR类|左右都出现过的属性|**A, C, E**|
|N类|在函数依赖中没出现过的属性|**无**|

---

## 🧮 步骤2：初步候选码组合（L ∪ N）

初始考虑：  
**{B, D}** 是唯一只能出现在左边的属性，我们试图从它开始构造候选码。

---

## 🔍 步骤3：计算闭包（{B, D}⁺）

我们看 {B, D} 能不能推全：

1. 初始：{B, D}
    
2. 能用哪个依赖？暂时都不能！因为：
    
    - AB → C（没有 A）
        
    - CD → E（没有 C）
        
    - E → A（没有 E）
        
    - A → G（没有 A）  
        👉 推不出新属性，  
        ⛔ 所以 {B, D}⁺ = {B, D} ≠ R  
        → **不是候选键，需要加入 LR 类属性**
        

---

## 🧪 步骤4：加入 LR 属性组合尝试

LR 属性是：A, C, E，我们来尝试将它们逐个加入到 {B, D}，看看什么时候能推满 R。

---

### ✅ 尝试 {A, B, D} 的闭包：

1. 初始：{A, B, D}
    
2. A → G ⇒ 加 G → {A, B, D, G}
    
3. AB → C ⇒ 加 C → {A, B, C, D, G}
    
4. CD → E（此时有 C 和 D）⇒ 加 E → {A, B, C, D, E, G}
    
5. E → A，已存在 ⇒ 忽略
    

👉 得到全集 R = {A, B, C, D, E, G}  
✅ 所以 **ABD 是候选键**。

---

### ✅ 尝试 {B, C, D} 的闭包：

1. 初始：{B, C, D}
    
2. CD → E ⇒ 加 E → {B, C, D, E}
    
3. E → A ⇒ 加 A → {A, B, C, D, E}
    
4. A → G ⇒ 加 G → {A, B, C, D, E, G}
    
5. AB → C（已经有 A 和 B，C 已在）
    

👉 得到全集 R ⇒ ✅ **BCD 是候选键**

---

### ✅ 尝试 {B, E, D} 的闭包（E 是 LR 类）

1. 初始：{B, D, E}
    
2. E → A ⇒ 加 A → {A, B, D, E}
    
3. A → G ⇒ 加 G → {A, B, D, E, G}
    
4. AB → C ⇒ 有 A、B ⇒ 加 C → {A, B, C, D, E, G}
    
5. CD → E ⇒ 有 C、D ⇒ E 已有
    

👉 ✅ 也能推出全集 ⇒ **BED 也是候选键**

---

## ✅ 步骤5：列出全部候选键

我们发现，以下组合都可以推出全集：

- ABD
    
- BCD
    
- BED
    

---

## 🎯 最终答案：

> **候选码集合 = {ABD, BCD, BED}**

这些都是**能唯一标识关系中一行数据、且最小化的属性组合**。

---
