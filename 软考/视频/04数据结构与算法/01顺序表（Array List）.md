## ✨ 基本概念

顺序表（Array List）是**用一块连续的存储空间**，**按照元素的逻辑顺序依次存放数据元素**的数据结构。

简而言之：

> “像排排坐的同学，每人有固定的座位号（下标），想找谁直接点名。”

---

## 🏗️ 结构示意图

```plaintext
索引:    0    1    2    3    4    5    ...    n-1
元素:   [A]  [B]  [C]  [D]  [E]  [F]   ...  [N]
```

- **索引（下标）**：标识元素在表中的位置（从0开始）
    
- **元素**：存储在顺序表中的数据
    

---

## 📚 顺序表特点

|特点|说明|
|---|---|
|访问速度快|通过下标，O(1) 时间复杂度直接访问任意元素|
|插入/删除慢|需要搬家（移动大量元素），最坏情况下时间复杂度 O(n)|
|空间连续|必须一块连续的内存，容量固定或需动态扩容（如 ArrayList）|
|支持随机访问|支持通过下标快速定位|

---

## 🚀 主要操作

### 1. 查找元素

- **按位置查找**：直接通过下标访问，时间复杂度 O(1)
    
- **按值查找**：遍历所有元素，时间复杂度 O(n)
    

### 2. 插入元素

- 选定插入位置后，需要**把插入位置及后面的元素全部往后挪一格**
    
- 时间复杂度 O(n)
    

### 3. 删除元素

- 删除指定位置元素后，需要**把后续所有元素往前挪一格**
    
- 时间复杂度 O(n)
    

### 4. 更新元素

- 直接根据下标修改，时间复杂度 O(1)
    

---

## 🧠 小技巧记忆

|类比|说明|
|---|---|
|教室排座位|插入一个新同学，后面所有人都要往后挪一挪|
|传纸条找人|按位置找快，按名字找慢，需要一个个问|
|买新鞋换大鞋柜|空间不够时，要重新开更大的空间存放|

---

## ⚡ 优缺点总结

|优点|缺点|
|---|---|
|支持随机访问，访问速度快|插入删除效率低，需频繁移动元素|
|存储结构简单，容易实现|空间必须连续，扩容代价高|
|适合读多改少的场景（如排行榜、静态数组）|不适合频繁插入删除的场景|

---

## 🏆 应用场景

- 需要**频繁访问**，**很少插入删除**的场景  
    👉 如：排行榜、课程表、静态数据展示
    
- Java 中的 `ArrayList`、Python 的 `list`，底层就是顺序表。
    

---

>[!seccess]
>设顺序线性表中有n个数据元素，则删除表中第i个元素需要移动n-i个元素。

​
>[!seccess]
当两个有序顺序表中，较小表（n个元素）的所有元素均小于较大表（m个元素）的最小元素时，只需比较n次即可完成归并（每次用较小表的元素与较大表的首元素比较）。因此，最少比较次数为n次。
