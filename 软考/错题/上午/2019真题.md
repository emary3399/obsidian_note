### 原题：

> 某系统由3个部件构成，每个部件的千小时可靠度都为R，该系统的千小时可靠度为 (1-(1-R)²)R，则该系统的构成方式是（ ）。
> 
> **作答**  
> [单选题]  
> A 3个部件串联  
> B 3个部件并联  
> C 前两个部件并联后与第三个部件串联  
> D 第一个部件与后两个部件并联构成的子系统串联

| 系统结构              | 系统可靠度公式                           | 记忆口诀        |
| ----------------- | --------------------------------- | ----------- |
| **串联系统**          | Rₛ = R₁ × R₂ × R₃                 | 串联看最差，连乘不假  |
| **并联系统**          | Rₛ = 1 - (1 - R₁)(1 - R₂)(1 - R₃) | 并联看最好，1减连乘差 |
| **部分并联后串联**（前并后串） | Rₛ = (1 - (1 - R₁)(1 - R₂)) × R₃  | 先算并后乘串      |
| **部分串联后并联**（前串后并） | Rₛ = 1 - (1 - R₁ × R₂)(1 - R₃)    | 先算串后减并      |

---


✅ 题目原文：  
已知有序数组a的前10000个元素是随机整数，现需查找某个整数是否在该数组中。以下方法中，（ ）的查找效率最高。


### 题目解析：

- 数组**已经有序**。
    
- 题目问的是**查找效率最高**。
    

---

### 选项分析：

|方法|适用场景|时间复杂度|是否适合本题|
|---|---|---|---|
|A. 二分查找法|有序数组|O(log n)|✅ 非常适合|
|B. 顺序查找法|无序或有序数组|O(n)|❌ 较慢，不推荐|
|C. 逆序查找法|无序或有序数组|O(n)|❌ 和顺序查找一样慢|
|D. 哈希查找法|无序集合（需额外建哈希表）|O(1)（建好后）|❌ 有序数组未建哈希表，需额外构建哈希，效率反而低|

---

### 结论：

**正确答案是 A. 二分查找法**  
理由：数组已排序，直接使用二分查找最优，时间复杂度 O(log n)，不需要额外结构。

---

**原题：**  
（ ）防火墙是内部网和外部网的隔离点，它可对<font color="#ff0000">应用层</font>的通信数据流进行监控和过滤。

**作答：**  
[ 单选题 ]  
A. 包过滤  
B. 应用级网关  
C. 数据库  
D. WEB

---

- **A. 包过滤**：  
    包过滤防火墙通常只会分析数据包的头部信息（如IP地址、端口号等），它工作在网络层，而不是应用层。它并不深入分析数据包的具体内容。因此，它不能做到监控和过滤应用层的数据流，显然不符合题意。
    
- **B. 应用级网关**：  
    应用级网关防火墙也叫做“代理防火墙”，它工作在应用层。它不仅可以过滤和监控数据包，还能深入分析应用层的数据内容，比如HTTP请求、FTP流量等。简而言之，应用级网关可以像“保安”一样检查你发送和接收的“信件”，确保它们不包含恶意内容。因此，这个选项符合题意，是正确答案。
    
- **C. 数据库**：  
    数据库是用来存储和管理数据的，与防火墙完全不同。它并不涉及网络流量的监控或过滤。所以这个选项明显不对。
    
- **D. WEB**：  
    WEB指的是万维网，和防火墙的监控过滤功能没有直接关系，它也不会做数据流的过滤工作。
    

所以，答案是 **B. 应用级网关**，它是能根据应用层内容过滤数据流的防火墙类型。

---

![[Pasted image 20250513174126.png]]




---


### 原题：

TCP和UDP协议均提供了（ ）能力。
A. 连接管理  
B. 差错校验和重传  
C. 流量控制  
D. 端口寻址

正确答案是：  
**D 端口寻址**

---

### 解析：

|功能|TCP|UDP|
|---|---|---|
|连接管理|有|无|
|差错校验和重传|有|无（仅有基本校验，不重传）|
|流量控制|有|无|
|端口寻址|有|有|

#### ✅ 端口寻址

- TCP 和 UDP 都使用端口来标识通信的进程。
    
- 端口号 + IP 地址 构成套接字，负责寻址和通信。
    

#### ❌ 连接管理

- 只有 TCP 是面向连接（需要建立、维护和释放连接）。
    
- UDP 是无连接的，直接发送。
    

#### ❌ 差错校验和重传

- TCP 有差错校验、自动重传机制。
    
- UDP 只有简单校验和（不保证可靠传输，不重传）。
    

#### ❌ 流量控制

- TCP 有流量控制（比如基于滑动窗口）。
    
- UDP 没有流量控制。

---


### 📋 题目复述：

在关系代数表达式的查询优化中，下列说法**错误**的是（ ）。

A. 提早执行<font color="#ff0000">选择</font>运算  
B. 合并乘积与其后的选择运算为<font color="#ff0000">连接</font>运算  
C. 如投影运算前后存在其它的二目运算，应优先处理投影运算  
D. 存储公共的子表达式，避免重新计算

---

### ✅ 正确答案：

**C. 如投影运算前后存在其它的二目运算，应优先处理投影运算**

---

### 🎯 解析：

关系代数的查询优化主要遵循“尽早减少数据量”的原则，但不同运算的优化时机和方法要注意区分：

|方法|是否正确|原因|
|---|---|---|
|提早执行选择运算|✔️|选择操作可以减少数据量，应该尽早执行。|
|合并乘积与其后的选择运算为连接运算|✔️|可以将“笛卡尔积 + 选择”优化为连接运算，减少中间结果规模。|
|**投影运算优先执行**|❌|投影在涉及二目运算（如连接、并、交、差）时不宜过早执行，因为提前投影可能会丢失必要的连接属性，导致查询结果不正确。通常投影运算应尽可能延后，在不影响查询正确性的前提下进行。|
|存储公共的子表达式，避免重复计算|✔️|避免重复计算，提升效率。|

---

### 🎯 总结口诀

> 选择尽早做，连接紧跟着。  
> 投影要慎重，别太早去做。

---

### 📋 题目复述：

**题目1**  
给定关系 R(A, B, C, D) 与 S(C, D, E, F)，  
则 RxS 与 R⨝S 操作结果的属性个数分别为（ ）。

A. 8, 6  
B. 6, 6  
C. 8, 8  
D. 7, 6

---

**题目2**  
与表达式 π2,3,4(σ2<5(R⨝S)) 等价的 SQL 语句如下：

```sql
SELECT R.B, R.C, R.D 
FROM R, S 
WHERE （ ）
```

A. R.C=S.C OR R.D=S.D OR R.B < S.C  
B. R.C=S.C OR R.D=S.D OR R.B < S.E  
C. R.C=S.C AND R.D=S.D AND R.B<S.C  
D. R.C=S.C AND R.D=S.D AND R.B<S.E

---

### ✅ 正确答案：

- **题目1：A. 8, 6**
    
- **题目2：D. R.C=S.C AND R.D=S.D AND R.B<S.E**
    

---

### 🎯 题目1 解析：

- **RxS**：  
    笛卡尔积，属性为 R 和 S 所有属性之和。  
    R 有 4 个属性 (A, B, C, D)，S 有 4 个属性 (C, D, E, F)。  
    笛卡尔积后的属性个数 = 4 + 4 = **8**。
    
- **R⨝S**（自然连接）：  
    根据相同属性 C 和 D 进行连接，因此 C 和 D 只保留一次，其他属性不变。  
    最终属性 = A, B, C, D, E, F = **6 个属性**。
    

---

### 🎯 题目2 解析：

- π2,3,4：投影第 2、3、4 列，即 R 的 B、C、D。
    
- σ2<5：选择第 2 列小于 5，注意在 R⨝S 中：
    
    - R 的属性顺序是 A, B, C, D；
        
    - S 的属性顺序是 E, F；
        
    - 根据自然连接，最终属性是 A, B, C, D, E, F。
        

所以，第 2 列是 B，条件为 R.B < 5。

但根据题目，使用 SQL 语句，还要表达 R⨝S：

```sql
R.C=S.C AND R.D=S.D
```

然后加上选择条件：

```sql
R.B < S.E
```

因为 SQL 的 where 条件必须用 S.E，而不能直接用 5（因为投影只给了 S.E）。

所以正确 SQL 是：

```sql
SELECT R.B, R.C, R.D
FROM R, S
WHERE R.C=S.C AND R.D=S.D AND R.B<S.E
```

即选项 **D**。

---

### ✅ 题目复述：

已知两个表：

```sql
Emp(eno, ename, age, sal, dname)
Dept(dname, phone)
```

要查找：

> 其他部门比“Sales”部门所有员工年龄都小的员工姓名和年龄。

---

### 🔥 问题1解析（选择比较运算符）：

**关键句型**

```sql
WHERE age <ALL (SELECT age FROM Emp WHERE dname = 'Sales')
```

#### 分析：

- 题目要求：
    
    - 找**年龄小于 Sales 部门所有员工的员工**。
        
    - 即自己的 age 必须小于 Sales 部门所有人的 age。
        
- 所以要使用：
    
    - `age <ALL (SELECT age FROM Emp WHERE dname = 'Sales')`
        
    - `ALL` 的含义是：必须小于 Sales 部门的所有员工年龄（**强约束**）。
        
- 注意：
    
    - 如果选 `<ANY`，那是只要小于 Sales 部门任意一个人就行（**弱约束**），显然不对。
        

**✅ 答案：A `<ALL`**

---

### 🔥 问题2解析（部门排除条件）：

- 因为题目说**其他部门**，要把 Sales 自己排除。
    
- SQL 写法：
    
    ```sql
    dname <> 'Sales'
    ```
    
- 不能用 =、>、< 这种运算符。
    

**✅ 答案：B `dname <> 'Sales'`**

---

### 🎯 综合正确 SQL：

```sql
SELECT ename, age
FROM Emp
WHERE age <ALL (SELECT age FROM Emp WHERE dname = 'Sales')
AND dname <> 'Sales';
```

---

### 🧠 记忆技巧：

|需求|SQL运算符|
|---|---|
|年龄小于 Sales 所有员工年龄|`<ALL`|
|排除 Sales 部门|`dname <> 'Sales'`|

> 口诀：  
> **“比所有用 ALL，别自己就用 <>”**  
> ALL 是强条件，ANY 是弱条件，EXISTS 是存在，IN 是列表匹配。

---

### ✅ 题目复述：

> 以下有关数据库**触发器（Trigger）**的叙述中，哪一项是错误的？

---

### 🔍 选项逐条解析：

#### A. 触发器可以执行约束、完整性检查

- ✔ 正确。
    
- 触发器的常见用途之一就是执行复杂的约束和业务规则，进行完整性检查，防止非法数据进入。
    

#### B. 触发器中不能包含事务控制语句

- ✔ 正确。
    
- 大部分数据库（如 Oracle、MySQL）不允许在触发器里直接写事务控制（如 COMMIT、ROLLBACK）。因为触发器是自动执行的，不应该破坏外层事务的一致性。
    

#### C. 触发器不能像存储过程一样，被直接调用执行

- ✔ 正确。
    
- 存储过程是手动调用（`CALL proc_name`），而触发器是被动的，自动响应事件（如 INSERT、DELETE、UPDATE）。
    

#### D. 触发器不能在临时表上创建，也不能引用临时表

- ❌ 错误。
    
- 正确说法应该是：
    
    - **大部分数据库允许在临时表上创建触发器（如 SQL Server 支持）**。
        
    - 但是某些数据库（如 Oracle）**不允许在临时表上创建触发器**。
        
    - 题干说得太绝对，说“不能”，实际上是看数据库厂商实现，并非通用规则。
        
    - 因此这个说法**存在争议，不能一概而论，属于题目中的错误选项**。
        

---

### 🎯 正确答案：

**D**

---

### 🧠 记忆口诀：

> **触发自动、过程手动；事务禁写、规则管够；临时表触发视产品，不能一概而论。**

---

以下关于**最小函数依赖集**的说法中，<font color="#ff0000">不</font>正确的是（ ）。

### 选项

A. 不含传递依赖  
B. 不含部分依赖  
C. 每个函数依赖的右部都是单属性  
D. 每个函数依赖的左部都是单属性

---

### ✅ 正确答案

**D**

---

### 🎯 解析

**最小函数依赖集**（也叫**规范化函数依赖集**）有以下基本特点：

|要求|说明|
|---|---|
|1|每个函数依赖的**右部必须是单属性**（拆分右边多属性为多个单属性依赖）|
|2|不存在**冗余的函数依赖**（去掉任一依赖，闭包变化，不能去）|
|3|不存在**冗余的左部属性**（左侧如果多个属性，不能随意删，除非能推导出相同结果）|

#### 其他选项解释：

- A 正确：最小依赖集中不保留能由其他依赖推导出来的（即不含传递依赖）。
    
- B 正确：最小依赖集中左边不含冗余，意味着部分依赖被去除。
    
- C 正确：右部必须单属性。
    

---


### ❓题目

已知关系模式  
R<{A, B, C}, {AC → B, B → C}>  
则：

1. 候选码之一是（ ）
    
2. 该模式存在主属性对码的部分函数依赖，其规范化最高属于（ ）
    

---

### 📝 解题过程

#### 问题 1：求候选码

- 给定属性：A, B, C
    
- 函数依赖：
    
    - AC → B
        
    - B → C
        

##### 分析候选码

1. **AC → B**
    
    - AC 决定 B
        
2. **B → C**
    
    - B 决定 C
        

##### 尝试计算闭包

- **AC+**
    
    - AC
        
    - AC → B ⇒ AC, B
        
    - B → C ⇒ AC, B, C
        
    - 最终得到 {A, B, C}
        
    - 所以 **AC 是候选码**。
        

##### 其他组合

- **A+**
    
    - 只有 A，无法推到 B 或 C
        
    - ❌
        
- **AB+**
    
    - AB
        
    - B → C ⇒ AB, C
        
    - 得到 {A, B, C}
        
    - **AB 也是候选码**。
        

所以候选码有 AC 和 AB。  
**答案选 B（AB）** （因为题目问之一，AB在选项里）

---

#### 问题 2：规范化分析

##### 主属性

- 候选码：AC、AB
    
- 主属性：A、B、C（全部都是）
    

##### 分析部分依赖

- B → C
    
    - B 是候选码的一部分（AB），B 单独决定 C，**存在部分依赖**
        

##### 规范化程度

- 存在部分依赖，**属于 2NF**
    
- 无法达到 3NF（要消除部分依赖）
    

所以答案是：**2NF**

---

### ✅ 最终答案

|问题|答案|
|---|---|
|候选码之一|B. AB|
|规范化最高|2NF|

---

题目大意：  
你有一个关系 rr，把它分成两个小关系 r1r_1 和 r2r_2。然后你把这两个小关系 r1r_1 和 r2r_2 合并（通过自然连接）。如果合并后的结果比原来 rr 的记录多，就说明这种分解是有问题的。

选项解释：  
A. **保持函数依赖的分解**：这种分解不会丢失原来关系里的规则（函数依赖）。但是如果连接后记录增多，通常说明函数依赖没保持，不能选这个。  
B. **不保持函数依赖的分解**：这种分解可能丢失了一些原有的规则。连接后记录增多，可能是因为丢了些信息，所以这个也不对。  
C. **无损连接的分解**：这表示通过分解和连接后，得到的结果与原始数据完全一样，没有丢失任何信息。既然记录多了，肯定不是无损连接。  
D. **有损连接的分解**：这就是问题所在。如果连接后记录比原来的多，说明信息可能重复或者丢失了，这就是所谓的“有损”情况。

所以正确答案是 **D. 有损连接的分解**。

---
  
将具有特定功能的一段SQL语句(多于一条)在数据库服务器上进行预先定义并编译，以供应用程序调用，该段SQL程序可被定义为（ ）。

选项解释：  
A. **事务**：事务是指一组操作，要么全做，要么全不做。它并不是预定义的 SQL 程序，和我们这个问题的描述不符。  
B. **触发器**：触发器是数据库中一个特殊的程序，它会在某些特定事件（比如插入、更新、删除）发生时自动执行。但它不是预先定义来供应用程序调用的程序。  

C. **视图**：视图是一个虚拟的表，存储的是一个查询的结果。它不能包含逻辑处理，只是为了简化查询操作。  

D. **存储过程**：存储过程是数据库中预先编译并保存的一段 SQL 程序，可以包含多条 SQL 语句，应用程序可以调用它来执行特定的功能。

因此，正确答案是 **D. 存储过程**。

---

题目复述：  
关于日志文件，下列说法错误的是（ ）。

选项解析：  
A. **保存了更新前的数据**：日志文件确实会保存事务的修改前后的数据，以确保在事务失败时能进行回滚操作。因此，这个说法是正确的。  
B. **保存了更新后的数据**：日志文件会记录事务执行后的数据，保证在事务提交后能够恢复操作。所以，这个说法是正确的。  
C. **无需其它文件可恢复事务故障**：日志文件确实可以在发生事务故障时通过回滚或重做操作来恢复事务。这是日志文件的一个关键功能。所以，这个说法是正确的。  
D. **无需其它文件可恢复介质故障**：介质故障是指硬件故障（比如硬盘损坏），这种情况下单独依赖日志文件无法完全恢复数据。通常，还需要数据文件和其他备份文件的配合。所以，这个说法是错误的。

因此，正确答案是 **D. 无需其它文件可恢复介质故障**。

---
题目复述：  
在索引改进中，一般的调整原则是：

- 当（ ）是性能瓶颈时，则在关系上建立索引；
    
- 当（ ）是性能瓶颈时，则考虑删除某些索引；
    
- 管理人员经常会将有利于大多数数据查询的索引设为（ ）。
    

**问题1解析**：

- **查询**是数据库中常见的性能瓶颈，特别是在数据量大时，查询会变得很慢。为了提高查询效率，可以通过建立索引来加速查询操作。所以，正确答案是 **A. 查询**。
    
- **更新**、**排序**、**分组计算** 都与建立索引的直接关系不大，主要影响的是数据的插入、更新或者聚合操作。
    

**问题2解析**：

- 当 **更新** 是性能瓶颈时，通常是因为索引会导致额外的开销（每次更新时都要维护索引）。因此，若更新操作频繁且对性能影响较大，可以考虑删除某些索引以提高更新性能。所以，正确答案是 **B. 更新**。
    
- **查询**、**排序**、**分组计算** 主要是与数据读取相关，而不是与更新相关。
    

---


**题目**：  
以下有关数据库审计的叙述中，**错误的是（ ）**。

**选项**：

- A. 审计记录数据库资源和权限的使用情况
    
- B. 审计可以防止对数据库的非法修改
    
- C. 审计操作会影响系统性能
    
- D. 审计跟踪信息会扩大对存储空间的要求
    

---

### 逐项解析：

**A. 审计记录数据库资源和权限的使用情况**  
✅ 正确。  
数据库审计的核心任务之一就是记录用户对数据库的访问、资源使用、权限操作等。

**B. 审计可以防止对数据库的非法修改**  
❌ 错误。  
审计的作用是**记录和追踪**，**不能主动阻止**。  
就像监控摄像头，它可以拍下小偷，但不能主动去抓小偷。所以审计只能帮助事后发现非法修改，并不能防止。

**C. 审计操作会影响系统性能**  
✅ 正确。  
开启审计时，数据库要记录额外信息，会增加 CPU、IO 负担，确实会带来性能开销。

**D. 审计跟踪信息会扩大对存储空间的要求**  
✅ 正确。  
因为审计信息要单独存储，因此会占用额外的存储空间。

---

### 正确答案是：

**B. 审计可以防止对数据库的非法修改**

---


**题目**：  
以下关于 NoSQL 数据库的说法中，**正确的是（ ）：

**选项**：  
A. NoSQL 数据库保证 BASE 特性  
B. NoSQL 数据库保证 ACID 特性  
C. 各种 NoSQL 数据库具有统一的架构  
D. NoSQL 数据库经常使用 JOIN 操作

---

### 正确答案是：**A. NoSQL 数据库保证 BASE 特性**

---

### ✅ 逐项解析：

#### **A. NoSQL 数据库保证 BASE 特性** ✅ 正确

BASE 是 NoSQL 中提出的概念，全称是：

- **Basically Available**（基本可用）
    
- **Soft state**（软状态）
    
- **Eventually consistent**（最终一致性）
    

这套理念是为了**高可用、大并发**牺牲部分强一致性而提出的，是 NoSQL 的核心特征之一。

---

#### **B. NoSQL 数据库保证 ACID 特性** ❌ 错误

ACID 是关系型数据库（如 MySQL、Oracle）强调的事务特性：

- 原子性（Atomicity）
    
- 一致性（Consistency）
    
- 隔离性（Isolation）
    
- 持久性（Durability）
    

而 NoSQL 为了可扩展性，**往往不严格保证 ACID**，尤其是在大数据、高并发场景下。

---

#### **C. 各种 NoSQL 数据库具有统一的架构** ❌ 错误

完全错误。  
NoSQL 是个大杂烩，包括：

- **键值型**（如 Redis）
    
- **文档型**（如 MongoDB）
    
- **列族型**（如 HBase）
    
- **图数据库**（如 Neo4j）  
    每种都有**不同架构和使用场景**。
    

---

#### **D. NoSQL 数据库经常使用 JOIN 操作** ❌ 错误

NoSQL 数据库普遍**不支持 JOIN**，或者说很少用。  
数据通常通过嵌套、冗余的方式组织，**以牺牲规范化换取性能和灵活性**。

---

### 🧠 小总结口诀：

> NoSQL 保 BASE，不讲 ACID 不 JOIN；  
> 架构各不同，性能往上冲！


---
