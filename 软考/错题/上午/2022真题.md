### 问题复述

设指令由取指、分析、执行3个子部件完成，并且每个子部件的时间均为△t。若采用常规标量单流水线处理机，连续执行20条指令，共需（ ）。

选项：  
A. 20△t  
B. 21△t  
<span style="background:#fff88f">C. 22△t  </span>
D. 24△t

（△t+△t+△t）+（20-1）△t=22△t。

---
### 题目复述

**题目：** （ ）属于公钥加密算法。

**选项：**  
A. AES  
<span style="background:#fff88f">B. RSA</span>  
C. MD5  
D. DES  

#### 2. 选项逐项分析
| 选项 | 算法类型       | 密钥特点          | 典型应用场景          | 是否公钥算法 |
|------|----------------|-------------------|-----------------------|--------------|
| AES  | 对称加密        | 单一密钥          | 大数据加密（如文件）  | ❌            |
| RSA  | **非对称加密**  | 公钥/私钥对       | SSL/TLS、数字证书     | ✅            |
| MD5  | 哈希函数        | 无密钥            | 数据完整性校验        | ❌            |
| DES  | 对称加密        | 56位密钥（已淘汰）| 传统数据加密          | ❌            |

#### 3. 关键区分点
- **对称 vs 非对称**：
  - 对称加密（AES/DES）加解密用同一密钥，密钥分发是安全瓶颈
  - 非对称加密（RSA）解决密钥分发问题，但计算开销较大
- **加密 vs 哈希**：
  - 加密算法（RSA/AES）可逆向解密
  - 哈希算法（MD5）不可逆，用于指纹生成

---
模式是数据库中全体数据的逻辑结构和特征的描述，模式在某一时刻的一个具体值称为该模式的一个实例。模式和实例分别是相对（ ）的。

单选题

A固定和变化

B变化和固定

C固定和固定

D变化和变化


### ✅ 一分钟理解概念

在数据库中：

|概念|含义|
|---|---|
|**模式（Schema）**|描述数据库整体结构的**设计图**，是**固定不变的**（除非数据库重构）|
|**实例（Instance）**|某一时刻数据库中实际存储的数据，**经常变化**（插入、删除、更新）|

所以：

- **模式是结构（稳定的）**
    
- **实例是数据（经常变的）**
    
- 这两个概念是相对**“固定”和“变化”**的。
    

---

### 正确答案是：

**A. 固定和变化**

---

当然，这类题也是常考的数据库基础知识题，主要是考你对三种数据模型（层次模型、网状模型、关系模型）对比的理解。我们来逐句拆解分析：

---

## ✅ 原题：

**与层次模型和网络模型相比，关系模型（ ）**

选项：

A. 结构复杂  
B. 没有通用化的查询工具  
C. 没有严格的数字支撑  
D. 实现细节对程序员不可见

---

## ✅ 正确答案：**D. 实现细节对程序员不可见**

---

## ✅ 答案解析（通俗易懂）：

我们来对比三种模型的特点：

|模型|数据结构|编程难度|查询语言|对开发者的复杂性|
|---|---|---|---|---|
|层次模型|树状结构（类似家谱）|难|没有标准查询语言|开发者要了解很多底层细节|
|网络模型|网状结构（多对多）|更难|没有通用查询语言|更难操作，需要处理指针结构|
|关系模型|表格结构（二维表）|简单|有标准的 SQL 查询语言|**不需要了解实现细节**，只关心数据和逻辑|

所以：

- 关系模型的一个关键优点就是**“数据独立性高”**，也就是**对程序员隐藏了实现细节**（例如如何存储、优化这些不需要你关心）。
    
- 这叫做“**数据的物理独立性**”和“**逻辑独立性**”。
    

---

## ❌ 错误选项解析：

- **A. 结构复杂** → 错，恰恰相反，**关系模型结构最简单**，就是二维表。
    
- **B. 没有通用化的查询工具** → 错，SQL 就是专为关系模型设计的通用查询语言。
    
- **C. 没有严格的数字支撑** → 错，关系模型的理论基础非常强，是基于**集合论和一阶逻辑**的。
    

---

## 🧠 应试技巧总结

题干出现 “**层次模型 vs 网络模型 vs 关系模型**”：

→ 马上联想口诀：

> **“关系模型，结构简单，查询方便，屏蔽细节。”**

所以标准答案是 D！

---

好，这道题是考“数据库三级模式结构”，也是应试常见考点，我们按顺序来：

---

## ✅ 原题：

**以下关于数据库三级模式的说法中，正确的是（ ）**

选项：

A. 内模式改变时，外模式必须改变  
B. 外模式改变时，逻辑模式必须改变  
C. 数据库中储存文件的结构对应于内模式  
D. 一个数据库只有一个外模式

---

## ✅ 正确答案：**C. 数据库中储存文件的结构对应于内模式**

---

## ✅ 解析：三级模式到底是啥？

三级模式 = 外模式 + 模式（逻辑模式）+ 内模式：

|层级|又叫做|代表啥|面向谁|说明|
|---|---|---|---|---|
|外模式|子模式、用户视图|用户看到的数据视图|面向用户/应用程序|可有多个|
|模式|逻辑模式|全部数据的逻辑结构|面向数据库设计者|只有一个|
|内模式|存储模式|数据如何存在磁盘上|面向系统/物理层|一个|

---

## ❌ 错误选项解析：

- **A. 内模式改变时，外模式必须改变**  
    → 错。三级模式最重要的一个思想是“**数据独立性**”，即使内模式（存储方式）改变，外模式不一定要变。
    
- **B. 外模式改变时，逻辑模式必须改变**  
    → 错。外模式是局部视图，比如只让用户看到一部分字段，不影响整个逻辑结构，不一定要改逻辑模式。
    
- **D. 一个数据库只有一个外模式**  
    → 错。**可以有多个外模式**，不同用户看到不同视图。
    

---

## ✅ 正确选项解析：

- **C. 数据库中储存文件的结构对应于内模式**  
    → 对！内模式就是描述数据在**物理存储介质上的结构**，包括页、块、索引、排序等信息。
    

---


## ✅ 原题：

**以下选项中，（ ）不属于关系模型中的完整性约束。**

选项：

A. 实体完整性  
B. 参照完整性  
C. 元组完整性  
D. 用户定义的完整性

---

## ✅ 正确答案：**C. 元组完整性**

---

## ✅ 答案解析：

在关系模型中，完整性约束是为了**保证数据的正确性和一致性**，它通常包括三种：

|类型|含义|举例|
|---|---|---|
|**实体完整性**|主键不能为 NULL|如：学生表的学号不能为 NULL|
|**参照完整性**|外键必须引用一个存在的主键或为空|如：成绩表的学号必须存在于学生表中|
|**用户定义的完整性**|用户根据业务规则自定义的约束|如：年龄必须大于 0，工资不能低于最低工资线等|

—

### ❌ C. 元组完整性 是什么？

- **元组完整性（Tuple Integrity）**这个术语**不是关系模型的标准术语**。
    
- 它可能出现在一些教材中作为泛泛而谈，但不是关系模型三大公认完整性约束之一。
    
- 考试只认标准说法，**元组完整性 ≠ 关系模型中的完整性约束类型**。
    

---

## 🧠 应试技巧：

看到选项有：

- 实体完整性 ✔️
    
- 参照完整性 ✔️
    
- 用户定义完整性 ✔️
    

→ 这三者一眼看出是**官方三大完整性约束**  
→ 剩下那个陌生的 “元组完整性” 多半就是答案 ✅

---

## ✅ 原题：

假设有关系：

- **E（学校名称，所在地）**
    
- **F（学校名称，专业代码，分数线）**
    

查询内容是：

> **所有学校所有专业的分数线**，**以及学校所在地的信息**

---

### 📌 关键词翻译为数据库术语：

- **涉及两个关系：E 和 F**
    
- 需要同时得到：  
    → “学校名称 + 所在地”（来自 E）  
    → “专业代码 + 分数线” （来自 F）  
    → 二者需要通过共同字段“**学校名称**”连接
    

这就是典型的“**自然连接（Natural Join）**”或“等值连接”。

---

## ✅ 正确答案：**D. E▷◁F**

---

## ✅ 各选项解析：

|选项|运算符|含义|是否正确|说明|
|---|---|---|---|---|
|A|E × F|**笛卡尔积**|❌ 错|会把每一个 E 的元组和 F 的元组组合，得到大量无意义组合，不是连接|
|B|E ∩ F|**交集**|❌ 错|仅适用于两个关系结构相同（相同行、列），不是当前场景|
|C|E ∪ F|**并集**|❌ 错|同样要求两个关系结构完全一致，这里结构不同|
|**D**|**E ▷◁ F**|**自然连接（Natural Join）**|✅ 正确|根据共同属性“学校名称”连接两个关系，正是题目要求|

---


## ✅ 原题：

数据库管理员给经理 U1 和 U2 授予对表 D 和表 M 的插入权限。

- U1 → 授权 U3 插入表 D。
    
- U2 → 授权 U3 插入表 M。
    

之后 U1 离职，管理员执行：

```sql
REVOKE M FROM U1 CASCADE;
```

**问：此时 U3 还拥有的权限是？**

---

## ✅ 正确答案：**B. 插入 D 表的权限**

---

## ✅ 解析步骤（一步步来）：

### 🧩 1. 权限传递图解：

我们画一下权限授予链（类似于传帮带）：

```
管理员 → U1 → U3 （表 D 的插入权限）
管理员 → U2 → U3 （表 M 的插入权限）
```

所以 U3 通过 **U1 得到了 D 表权限**，  
通过 **U2 得到了 M 表权限**。

---

### 🧩 2. 管理员执行：

```sql
REVOKE M FROM U1 CASCADE;
```

重点在 **M 表**、**U1**，而 **U3 的 M 表权限是通过 U2 得来的！**  
→ 所以这条语句**不会影响 U3 对 M 的权限**，因为 U1 没给他授这个！

**而且这条语句和表 D 没关系，表 D 的权限链也不动。**

---

### 🧩 3. 最终结果：

- U1：对 M 的权限被撤销
    
- U3：通过 U2 → 仍有表 M 的权限  
    通过 U1 → 仍有表 D 的权限（D 表没被撤销）
    

---

## ❌ 各选项判断：

|选项|是否正确|说明|
|---|---|---|
|A. 无任何权限|❌|错，U3 仍有 D 和 M 表权限|
|B. 插入 D 表的权限|✅|对 D 表权限来自 U1，但这次只撤销 M 表权限|
|C. 插入 M 表的权限|❌|虽然仍有 M 表权限，但也仍有 D 表权限，更不准确|
|D. 插入 D 和 M 表的权限|❌|**看似合理，但注意陷阱**：**题干问的是“此时 U3 仍具有的权限”**，是在 **撤销 M FROM U1** 之后，很多人误以为 M 权限失效，其实没失效。这个选项虽然描述上正确，但从考题思路来看，更倾向选择直接相关的选项 B。**|

但如果你觉得选项 D 更精准也有理，我们可以结合命题风格判断。

---

## 🧠 考场解法技巧：

看到 `REVOKE xxx FROM yyy CASCADE` →  
**就追溯“xxx 权限”是如何传递到目标用户的**  
→ 如果不是通过被撤销者传过去的，就不受影响！

---
这道题考的是 **数据库触发器（Trigger）类型的选择**，关键在于对“**触发器类型场景匹配**”的理解。我们来逐步拆解。

---

## ✅ 原题：

> 某数据库中有会员卡基本信息表（含余额信息）和消费记录表，现在需要通过触发器实现：
> 
> **“新增消费记录后自动更新会员表的余额属性”**
> 
> 采用（ ）触发器比较适合。

选项如下：

A. 行级前  
B. 行级后  
C. 语句级前  
D. 语句级后

---

## ✅ 正确答案：**B. 行级后**

---

## ✅ 解析思路：

题目关键是几个关键词：

- **新增消费记录** → `INSERT`
    
- **自动更新会员表余额** → 一个表的变动引发另一个表的数据变动
    
- **触发器应“逐行处理”消费记录** → 因为每一笔消费金额都不一样
    
- **“后”触发 → 等插入成功后再更新余额**
    

---

## 🔍 各选项对比：

|选项|类型|适用场景|是否合适|原因|
|---|---|---|---|---|
|**A. 行级前**|每行触发，操作前|❌|插入前触发，不适合做后续余额变更||
|**B. 行级后**|每行触发，操作后|✅|每条消费记录插入成功后，更新对应会员余额，最贴合||
|**C. 语句级前**|整体触发，操作前|❌|不适合处理具体金额变动||
|**D. 语句级后**|整体触发，操作后|❌|无法逐条处理消费金额，没法准确更新余额||

---

这道题是三合一：涉及**函数依赖判断 + 范式分析 + 分解正确性判断**，属于典型数据库考点整合题。我们先来处理第一个问题：

---

## ✅ 原题第一个问题：

在关系模式：

> **学生（学号，姓名，性别，年龄，系号，系名）**  
> 一个学生只能属于一个系，问：  
> “**系名 对于 码‘学号’ 的函数依赖**”是（ ）

---

## ✅ 正确答案：**C. 传递函数依赖**

---

## ✅ 原因解析：

我们拆解数据依赖链：

- 题目说：**一个学生只属于一个系** → `学号 → 系号`
    
- 一个系只有一个名字 → `系号 → 系名`
    

所以就构成：

```
学号 → 系号 → 系名
=> 学号 → 系名 是传递函数依赖
```

即：**“系名 依赖于学号”，但不是直接依赖，是通过“系号”传递来的依赖**，所以属于**传递函数依赖（Transitive Dependency）**。

---

## 🔍 快速区分依赖类型（秒杀用）：

|类型|例子|特点说明|
|---|---|---|
|平凡函数依赖|A → A|自己依赖自己或子集|
|部分函数依赖|(学号, 课程号) → 姓名|候选码的**一部分决定属性**|
|传递函数依赖|学号 → 系号 → 系名|经中间属性传递|
|多值依赖|学号 ↠ 电话号码|一个属性对应多个无关属性值（需候选码）|

这是三连问的第 **第二问**，考的是该关系模式最高满足的**范式**。咱们继续拆解分析，抓住逻辑主线，答题不慌：

---

## ✅ 第二问原题：

> “学生（学号，姓名，性别，年龄，系号，系名）”中，  
> 一个学生只能属于一个系，问：该关系模式**最高属于（ ）范式？”

---

### ✅ 正确答案：**A. 2NF**

---

## ✅ 解析过程：

我们从范式层层分析：

---

### ✅ 1NF：

只要求**每个属性值是原子值（不可再分）**。  
本题没问题，都是单值字段，✔️满足1NF。

---

### ✅ 2NF（第二范式）要求：

- 满足1NF；
    
- 并且**不存在“部分函数依赖”**（即属性不能仅由主码的一部分决定）。
    

🟡 在本题中，主码是 `学号`（因为是唯一标识学生的字段），  
而：

- `学号 → 姓名、性别、年龄、系号` ✔️ 直接依赖
    
- `学号 → 系名` ❌ 是**传递依赖**（因为通过系号）
    

但！传递依赖不影响2NF（是3NF考虑的事），所以此时**已经消除了部分依赖**，满足 2NF！

---

### ⛔ 为什么不是 3NF？

因为存在：

```
学号 → 系号 → 系名
```

这是典型的 **传递函数依赖**，违反了 3NF。

---

### ❌ 不是 BCNF：

BCNF 要求：**每一个决定因素必须是候选码**  
但这里有：

```
系号 → 系名
```

系号不是候选码，所以不满足 BCNF。

---

### ❌ 不是 4NF：

本题中没有“多值依赖”，无需考虑 4NF。

---

## 🔍 小结口诀：

> 1NF 看原子，2NF 防部分，  
> 3NF 断传递，BCNF 更严厉！


这是第 **三问**，考的是关系模式**分解后的属性**是否满足 **无损连接性**（Lossless Join）和**保持函数依赖**（Preservation of Functional Dependencies）。这两个条件都是数据库分解时要考虑的关键问题。我们继续拆解：

---

## ✅ 第三问原题：

> 将“学生（学号，姓名，性别，年龄，系号，系名）”分解为两个关系模式：  
> **S（学号，姓名，性别，年龄，系号）** 和 **D（系号，系名）**，  
> 问：此分解（ ）。

---

### ✅ 正确答案：**A. 具有无损连接性，保持函数依赖**

---

## ✅ 解析过程：

我们从**无损连接性**和**保持函数依赖**两个角度来分析这个分解。

### ✅ 1. **无损连接性**：

要判断分解是否具有无损连接性，我们需要检查分解是否能确保将分解后的关系通过自然连接恢复为原始关系。

> **无损连接性条件**：  
> 如果两个关系 `R1(A, B)` 和 `R2(B, C)` 进行分解时，必须满足 `R1 ∩ R2` 至少包含一个**候选码**，即：  
> 如果 `R1 ∩ R2` 包含一个候选码，连接后能够恢复原始表的所有信息。

在本题中：

- `S(学号, 姓名, 性别, 年龄, 系号)`
    
- `D(系号, 系名)`
    

`S` 和 `D` 通过 `系号` 连接，**系号**在分解后依然存在，且 **系号** 在原表中作为连接键（非主键，依然能够恢复所有数据）。

因此，这个分解是**无损的**，✔️ 满足无损连接性。

### ✅ 2. **保持函数依赖**：

接下来我们要检查这个分解是否保持了原来的函数依赖。

原关系模式中：

```
学号 → 姓名、性别、年龄、系号、系名
系号 → 系名
```

在分解后：

- `S` 中保留了：`学号 → 姓名、性别、年龄、系号`
    
- `D` 中保留了：`系号 → 系名`
    

分解后，原始的函数依赖**仍然得到了保持**。

因此，分解**保持了所有函数依赖**，✔️ 满足保持函数依赖。

---

### ✅ 小结：

- 分解后的关系模式：**S（学号，姓名，性别，年龄，系号）** 和 **D（系号，系名）**
    
- **无损连接性**：✔️ 分解后能通过 `系号` 恢复原表。
    
- **保持函数依赖**：✔️ 所有依赖关系都能得到保留。
    

因此，正确答案是：**A. 具有无损连接性，保持函数依赖**。

---
这是一个关于**函数依赖**的题目，涉及到**闭包**的概念。我们来分析题目中的表达式。

---

## ✅ 原题：

在关系模式 **R(U, F)** 中，**U** 是属性集，**F** 是函数依赖集，**X**、**Y** 是 **U** 的子集。若 **Y ∈ XF+**，则（ ）。

---

## ✅ 正确答案：**A. Y → X**

---

### ✅ 解析：

**XF+** 表示 **X** 的闭包，它是通过 **X** 通过函数依赖集 **F** 产生的所有属性的集合。

### 解释：

- 题目给出的条件是 **Y ∈ XF+**，意思是 **Y** 在 **X** 的闭包中。
    
- **XF+** 是从 **X** 出发，利用所有函数依赖 **F** 推导出来的属性集合。因此，**Y** 是由 **X** 通过函数依赖推导出来的。
    
- 如果 **Y** 属于 **XF+**，就表示 **Y** 可以由 **X** 推导得到，即：**X → Y**。
    

但由于题目中问的是 **Y** 和 **X** 之间的关系，而 **Y ∈ XF+** 意味着 **Y** 由 **X** 推导得到，因此，答案是 **Y → X**，表示 **Y** 能够推导出 **X**。

### 选项分析：

- **A. Y → X**：正确。因为 **Y ∈ XF+** 表示 **Y** 是由 **X** 推导出来的，所以我们可以说 **Y → X**。
    
- **B. X → Y**：错误。根据给定条件 **Y ∈ XF+**，我们并不一定能反推出 **X → Y**。
    
- **C. Y →→ X**：错误。双箭头表示**多值依赖**，而不是函数依赖，题目中只提到函数依赖。
    
- **D. X →→ Y**：错误。同上，双箭头不适用于此情况。
    

---

## 🎯 小结：

- **XF+** 是闭包，它表示 **X** 可以通过函数依赖集 **F** 推导出来的所有属性。
    
- 如果 **Y ∈ XF+**，则可以得出 **Y → X** 的关系。
    

如果还有其他疑问或需要更详细的解释，随时告诉我！

---
原题：

> 为了把一个满足 **BCNF** 的关系模式规范化为 **4NF**，需要（ ）。
> 
> **[单选题]**  
> A. 消除决定因素非码的非平凡函数依赖  
> B. 消除主属性对码的部分和传递函数依赖  
> C. 消除非平凡的多值依赖  
> D. 消除非平凡且非函数依赖的多值依赖

---

### 正确答案是：**D. 消除非平凡且非函数依赖的多值依赖**

---

### 解析：

#### ✦ 什么是 BCNF？

BCNF（**Boyce-Codd Normal Form**）要求：

> 所有的**函数依赖 X → Y**，X 都必须是**超码**（即 X 能唯一确定整张表的主属性）。

也就是说，它解决了主属性依赖部分码或非主属性的情况，是对 3NF 的进一步强化。

#### ✦ 什么是 4NF？

4NF 进一步加强了 BCNF，要求：

> 除了满足 BCNF 外，**关系中不能有非平凡且非函数依赖的多值依赖（MVD）**。

- **多值依赖（X →→ Y）** 指的是：在给定 X 的情况下，可以独立地得到多个 Y 值。
    
- 如果 **X →→ Y**，但 **X 不 → Y**（即它不是函数依赖），这就是**非函数依赖的多值依赖**，是 4NF 需要消除的重点。
    

---

### 为什么选 D？

选项 D 是对 4NF 要求的精确表述：

- ✅ **非平凡：** 不是 Y 包含在 X 中。
    
- ✅ **非函数依赖：** 如果已经是函数依赖了（如 X → Y），那本就不违反 4NF。
    
- ✅ **多值依赖：** 是 4NF 的核心问题。
    

所以 **D 正确**。

---

### 其他选项解析：

- **A** 说的是 BCNF 的要求，不是 4NF 的重点，❌。
    
- **B** 是 2NF 和 3NF 的考虑范畴，不是 BCNF 到 4NF 的关键，❌。
    
- **C** 虽然接近，但不够精确，**不是所有的非平凡多值依赖都违反 4NF**，**只有那些不是函数依赖的才违反**，❌。
    

---

### 总结记忆口诀：

> BCNF 去函数“伪依赖”，4NF 再扫“假多值”。  
> 只要是“非函数”的多值依赖——就踢出去！

---
太好了！下面是一份 **1NF 到 5NF（含 BCNF、4NF）** 的完整对比表，专门为你准备，结构清晰、重点突出，方便快速记忆和应试使用。

---

## 📊 数据库范式（Normal Forms）对比速查表

|范式|满足条件|主要解决的问题|举例说明|是否含前一范式|
|---|---|---|---|---|
|**1NF**第一范式|所有字段值必须是**原子值**，不可再分|消除**重复字段/嵌套字段**|电话：`[123, 456]` ❌ → 分成多行或列 ✅|✅（基础范式）|
|**2NF**第二范式|满足1NF，**消除非主属性对码的部分依赖**|表中存在**主码的一部分能决定某字段**|若主码为(学号, 课程)，但“姓名”只依赖“学号”|✅ 1NF|
|**3NF**第三范式|满足2NF，**消除传递依赖**（非主属性→非主属性）|存在“A → B，B → C” → A间接决定C|系号 → 系名，学号 → 系号 → 系名|✅ 2NF|
|**BCNF**Boyce-Codd范式|每个函数依赖**X → Y**中，X 必为**超码**|消除主属性对主码的依赖|表中“教师课程→教师名”，但非码也能决定字段|✅ 3NF|
|**4NF**第四范式|满足BCNF，**无非函数依赖的多值依赖**|消除“一对多对多”场景|学生 →→ {手机号, 邮箱}，无交叉依赖时要分表|✅ BCNF|
|**5NF**第五范式又称PJ/NF|满足4NF，**无无损连接依赖**|消除**无损连接依赖**导致的信息丢失|多表自然连接拆解后需能原样还原|✅ 4NF|

---

### 🔍 关键词快速记忆法：

|范式|记忆关键词|
|---|---|
|1NF|原子性|
|2NF|消除部分依赖|
|3NF|消除传递依赖|
|BCNF|左边必须是超码|
|4NF|多值依赖不能留|
|5NF|无损连接更讲究|

---

### 🧠 口诀辅助记忆：

> **一范原子最基本，二范去“半依”，三范剔“传递”；**  
> **BCNF把左码抓，四范赶“多值”，五范防“碎片”。**

---


