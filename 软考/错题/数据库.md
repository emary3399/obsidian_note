### ​**问题1：员工表属于哪种关系范式？​**​

​**正确答案：A. 非1NF关系**​

### ​**解析：多值属性与范式的关系**​

1. ​**第一范式（1NF）的核心要求**​：
    
    - 关系的每个属性必须是**原子（不可再分）​**，且不能有**多值属性**。
    - ​**​“联系电话”是多值属性**​（如一个员工有多个电话号），违反了1NF的原子性。
2. ​**其他范式的排除**​：
    
    - 1NF是基础，若不满足1NF，则更高范式（2NF/3NF）自动不满足。
    - 因此，选项B/C/D均错误。

---

### ​### ​**问题2：在SQL:1999标准中如何实现多值属性？​**​

​**正确答案：A. 集合类型**​

### ​**解析：SQL:1999对多值属性的支持**​

1. ​**集合类型（Collection Types）​**​
    
    - ​**ARRAY**​：固定长度的多值集合（如 `VARCHAR(20) ARRAY[5]` 存储最多5个电话号）。
    - ​**MULTISET**​：可变长度的多值集合（允许重复元素）。
    - ​**嵌套表（Nested Table）​**​：动态扩展的多值集合（需单独定义表类型）。
2. ​**其他选项排除**​
    
    - ​**B. CLOB类型**​：存储大文本（如长文章），不支持多值。
    - ​**C. BLOB类型**​：存储二进制数据（如图片），不支持多值。
    - ​**D. 结构类型**​：用于定义复杂对象（如`CREATE TYPE`），但不直接解决多值属性。
3. ​**SQL:1999示例**​
    

    ```sql
    -- 使用ARRAY存储多值联系电话
    CREATE TABLE 员工 (
        工号 INT PRIMARY KEY,
        姓名 VARCHAR(50),
        联系电话 VARCHAR(20) ARRAY[3]  -- 允许存储3个电话号
    );
    
    -- 使用嵌套表（需先定义类型）
    CREATE TYPE 电话类型 AS TABLE OF VARCHAR(20);
    CREATE TABLE 员工 (
        工号 INT PRIMARY KEY,
        姓名 VARCHAR(50),
        联系电话 电话类型  -- 多值存储
    ) NESTED TABLE 联系电话 STORE AS 电话表;
    ```
    

### ​**应试技巧**​

- 看到**多值属性**和**SQL:1999**​ → 直接选**集合类型**​（ARRAY/MULTISET/嵌套表）。
- CLOB/BLOB是单值大对象，结构类型用于复杂对象而非多值。

​**答案：A ✅**    ```
    

---

### **1NF（第一范式）详解**​

#### ​1. 定义

​**第一范式（1NF）​**是关系数据库设计的**最基本要求**，核心规则是：

- ​**每个属性（列）的值必须是原子的（不可再分）​**。
- ​**每行数据必须唯一，且不允许重复组或多值属性**。

#### ​**2. 关键要求**​

|要求|符合1NF的示例|违反1NF的示例|
|---|---|---|
|​**原子性**​|电话号码：`"13800138000"`|电话号码：`"13800138000,13900139000"`（多值）|
|​**无重复组**​|订单表分开存储商品ID和数量|订单表中一列存储`"商品1:2,商品2:3"`|
|​**列名唯一**​|列名为`姓名`、`年龄`|同一列存储`姓名`和`年龄`混合数据|

#### ​**3. 为什么重要？​**​

- ​**数据完整性**​：避免歧义（如拆分多值数据时可能出错）。
- ​**查询效率**​：原子数据更易索引和过滤。
- ​**后续范式的基础**​：2NF/3NF均以1NF为前提。

#### ​**4. 常见违反场景**​

- ​**多值属性**​（如员工有多个联系电话）。
- ​**复合字段**​（如地址合并为`"北京市海淀区中关村大街1号"`，需拆分为省/市/详细地址）。
- ​**重复组**​（如订单中同一单元格存储多个商品）。

#### ​**5. 如何满足1NF？​**​

- ​**拆分多值属性**​：
    - 错误：`联系电话: "123-456,789-012"`
    - 正确：新增从表（如`员工_电话`表），关联主键。
- ​**分解复合字段**​：
    - 错误：`地址: "北京市海淀区中关村"`
    - 正确：分列→ `省: "北京市"`, `市: "海淀区"`, `详细地址: "中关村"`。

#### ​**6. 示例对比**​

​**违反1NF的表（员工表）​**​

|工号|姓名|联系电话|
|---|---|---|
|001|张三|13800138000,13912345678|

#### ​**7. 应试技巧**​

- 看到**多值属性**或**复合字段**​ → 直接判断为**非1NF**。
- 1NF的核心是**原子性**，与数据是否冗余或依赖无关（这是2NF/3NF的事）。

​**总结**​：1NF是关系数据库的“底线”，确保数据可被高效、无歧义地存储和查询。

---
### ​**问题1：事务处理时，数据的修改内容先写入哪里？​**​

​**正确答案：C. 日志文件（Log File）​**​

### ​**问题2：系统正常运行时，数据库缓冲区内容写入哪里？​**​

​**正确答案：B. 数据文件（Data File）​**​

---

### ​**详细解析：数据库事务与恢复机制**​

#### ​**1. 事务处理的核心流程**​

为了保证数据安全，数据库采用 ​**WAL（Write-Ahead Logging）​**​ 机制：

1. ​**先写日志**​：任何数据修改（插入/删除/更新）​**先记录到日志文件**​（确保可追溯）。
2. ​**再写数据**​：日志记录成功后，才将数据写入内存缓冲区，最终刷盘到数据文件。

#### ​**2. 各文件的作用**​

|文件类型|用途|对应问题答案|
|---|---|---|
|​**日志文件**​|记录所有数据修改操作（如`UPDATE users SET name='张三' WHERE id=1`）|​**问题1选C**​|
|​**数据文件**​|存储实际数据（如用户表、订单表）|​**问题2选B**​|
|​**索引文件**​|加速查询（如B+树索引），与事务安全无关|❌ 不选|
|​**数据字典**​|存储元数据（如表结构定义），与事务无关|❌ 不选|

#### ​**3. 为什么先写日志？​**​

- ​**故障恢复**​：如果系统崩溃，数据库可以根据日志重放（Redo）或回滚（Undo）操作，保证数据一致性。
- ​**性能优化**​：日志是顺序写入（速度快），而数据文件可能随机写入（慢）。

#### ​**4. 缓冲区写入数据文件的时机**​

- ​**定期刷盘**​：系统按时间间隔（如每秒）将内存缓冲区的脏数据写入数据文件。
- ​**强制刷盘**​：事务提交时，确保日志持久化后，才允许缓冲区异步写入数据文件。

#### ​**5. 故障恢复示例**​

- ​**场景**​：系统在更新用户余额时断电。
    - ​**日志记录**​：`UPDATE accounts SET balance=500 WHERE id=100`（已写入日志文件）。
    - ​**数据文件未更新**​：内存缓冲区丢失，数据文件中余额仍为旧值。
    - ​**恢复过程**​：重启后根据日志重做（Redo）该操作，使数据文件与日志一致。

---

### ​**应试技巧**​

1. ​**关键词匹配**​：
    - 看到“先写入” → ​**日志文件**​（WAL机制的核心）。
    - 看到“缓冲区写入” → ​**数据文件**​（最终持久化位置）。
2. ​**排除法**​：
    - 索引文件和数据字典与事务安全无关，直接排除。

​**答案总结**​：

- ​**问题1：C（日志文件）​**​
- ​**问题2：B（数据文件）​**​

​**一句话记忆**​：  
​**​“日志记操作，数据存结果，先日志后数据，故障也不慌！”​**


---
